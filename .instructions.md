# Flutter Development Instructions for AI Assistants

> **Purpose:** Custom instructions for GitHub Copilot, Cursor, and other AI coding assistants.

---

## Project Context

This is a Flutter project using:
- **State Management:** BLoC/Cubit pattern with flutter_bloc
- **Backend:** Firebase (Auth, Firestore, Storage)
- **Navigation:** GoRouter with declarative routing
- **Architecture:** Clean Architecture with feature-first organization
- **Code Generation:** json_serializable, freezed for immutable classes

---

## Code Style Preferences

### General Dart Style

Follow [Effective Dart](https://dart.dev/effective-dart) with these specifics:

1. **Use expression bodies** for simple one-line functions:
   ```dart
   // ✅ Good
   String get fullName => '$firstName $lastName';

   // ❌ Avoid
   String get fullName {
     return '$firstName $lastName';
   }
   ```

2. **Always use trailing commas** for better formatting:
   ```dart
   Widget build(BuildContext context) {
     return Container(
       padding: const EdgeInsets.all(16),
       child: Column(
         children: [
           Text('Hello'),
           Text('World'),
         ],
       ),
     );
   }
   ```

3. **Prefer const constructors** wherever possible:
   ```dart
   const EdgeInsets.all(16)
   const SizedBox(height: 8)
   ```

4. **Use final for local variables** unless reassignment is needed:
   ```dart
   final user = context.read<AppBloc>().state.user;
   ```

5. **Avoid unnecessary null checks** with Dart's null safety:
   ```dart
   // ✅ Good
   String? email = user.email;

   // ❌ Avoid
   String? email = user.email != null ? user.email : null;
   ```

### Naming Conventions

**Files:**
- Use `snake_case` for all Dart files
- Pattern: `{feature}_{type}.dart`
- Examples: `user_repository.dart`, `app_bloc.dart`, `home_screen.dart`

**Classes:**
- Use `PascalCase`
- Add suffixes for clarity:
  - Blocs: `AppBloc`, `UserBloc`
  - Cubits: `FavoritesCubit`, `ThemeCubit`
  - Repositories: `UserRepository`, `AuthenticationRepository`
  - Screens: `HomeScreen`, `LoginScreen`
  - Models: No suffix (`User`, `Product`)

**Variables & Methods:**
- Use `camelCase`: `userName`, `getUserById()`
- Private members: `_privateVariable`, `_privateMethod()`
- Constants: `kConstantName` or `const constantName`

**Boolean Variables:**
- Prefix with `is`, `has`, `should`, `can`:
  ```dart
  bool isLoading = false;
  bool hasError = false;
  bool shouldShow = true;
  ```

---

## BLoC/Cubit Patterns

### When to Use BLoC vs Cubit

**Use BLoC:**
- Multiple event types (login, logout, refresh)
- Real-time Firestore stream subscriptions
- Complex business logic with multiple steps
- Global app-level state (authentication, user profile)

**Use Cubit:**
- Simple state toggles (on/off, loading/success)
- Form state management
- UI-specific state (theme preference, bottom sheet state)
- Single-purpose features (favorites, notifications)

### BLoC Implementation Pattern

```dart
// === EVENT ===
sealed class UserEvent extends Equatable {
  const UserEvent();
}

final class UserSubscriptionRequested extends UserEvent {
  const UserSubscriptionRequested(this.userId);
  final String userId;

  @override
  List<Object> get props => [userId];
}

final class UserUpdated extends UserEvent {
  const UserUpdated(this.user);
  final User user;

  @override
  List<Object> get props => [user];
}

// === STATE (use Freezed) ===
@freezed
class UserState with _$UserState {
  const factory UserState.initial() = _Initial;
  const factory UserState.loading() = _Loading;
  const factory UserState.success(User user) = _Success;
  const factory UserState.failure(String message) = _Failure;
}

// === BLOC ===
class UserBloc extends Bloc<UserEvent, UserState> {
  final UserRepository _userRepository;

  UserBloc({required UserRepository userRepository})
      : _userRepository = userRepository,
        super(const UserState.initial()) {
    on<UserSubscriptionRequested>(_onSubscriptionRequested);
    on<UserUpdated>(_onUserUpdated);
  }

  Future<void> _onSubscriptionRequested(
    UserSubscriptionRequested event,
    Emitter<UserState> emit,
  ) async {
    emit(const UserState.loading());

    await emit.forEach<User?>(
      _userRepository.watchUser(event.userId),
      onData: (user) => user != null
          ? UserState.success(user)
          : const UserState.failure('User not found'),
      onError: (error, _) => UserState.failure(error.toString()),
    );
  }

  Future<void> _onUserUpdated(
    UserUpdated event,
    Emitter<UserState> emit,
  ) async {
    try {
      await _userRepository.updateUser(event.user);
    } catch (e) {
      emit(UserState.failure(e.toString()));
    }
  }
}
```

### Cubit Implementation Pattern

```dart
// === STATE ===
class FavoritesState extends Equatable {
  const FavoritesState({
    this.favoriteIds = const [],
    this.isLoading = false,
    this.errorMessage,
  });

  final List<String> favoriteIds;
  final bool isLoading;
  final String? errorMessage;

  FavoritesState copyWith({
    List<String>? favoriteIds,
    bool? isLoading,
    String? errorMessage,
  }) {
    return FavoritesState(
      favoriteIds: favoriteIds ?? this.favoriteIds,
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage ?? this.errorMessage,
    );
  }

  @override
  List<Object?> get props => [favoriteIds, isLoading, errorMessage];
}

// === CUBIT ===
class FavoritesCubit extends Cubit<FavoritesState> {
  final FavoritesRepository _repository;

  FavoritesCubit(this._repository) : super(const FavoritesState());

  Future<void> loadFavorites(String userId) async {
    emit(state.copyWith(isLoading: true));
    try {
      final favorites = await _repository.getFavorites(userId);
      emit(state.copyWith(
        favoriteIds: favorites,
        isLoading: false,
      ));
    } catch (e) {
      emit(state.copyWith(
        isLoading: false,
        errorMessage: e.toString(),
      ));
    }
  }

  Future<void> toggleFavorite(String itemId) async {
    final isFavorite = state.favoriteIds.contains(itemId);
    try {
      if (isFavorite) {
        await _repository.removeFavorite(itemId);
        emit(state.copyWith(
          favoriteIds: state.favoriteIds.where((id) => id != itemId).toList(),
        ));
      } else {
        await _repository.addFavorite(itemId);
        emit(state.copyWith(
          favoriteIds: [...state.favoriteIds, itemId],
        ));
      }
    } catch (e) {
      emit(state.copyWith(errorMessage: e.toString()));
    }
  }
}
```

---

## Firebase Patterns

### Repository Structure

**Always follow this pattern for Firebase repositories:**

```dart
class UserRepository {
  final FirebaseFirestore _firestore;
  final FirebaseStorage _storage;

  UserRepository({
    FirebaseFirestore? firestore,
    FirebaseStorage? storage,
  })  : _firestore = firestore ?? FirebaseFirestore.instance,
        _storage = storage ?? FirebaseStorage.instance;

  /// Real-time subscription
  Stream<User?> watchUser(String userId) {
    return _firestore
        .collection('users')
        .doc(userId)
        .snapshots()
        .map((snapshot) {
      if (!snapshot.exists) return null;
      return User.fromFirestore(snapshot.data()!, snapshot.id);
    });
  }

  /// One-time fetch
  Future<User?> getUser(String userId) async {
    try {
      final doc = await _firestore.collection('users').doc(userId).get();
      if (!doc.exists) return null;
      return User.fromFirestore(doc.data()!, doc.id);
    } on FirebaseException catch (e) {
      throw UserRepositoryException.fromCode(e.code);
    } catch (e) {
      throw const UserRepositoryException();
    }
  }

  /// Create or update
  Future<void> saveUser(User user) async {
    try {
      await _firestore
          .collection('users')
          .doc(user.id)
          .set(user.toFirestore(), SetOptions(merge: true));
    } on FirebaseException catch (e) {
      throw UserRepositoryException.fromCode(e.code);
    }
  }

  /// Delete
  Future<void> deleteUser(String userId) async {
    try {
      await _firestore.collection('users').doc(userId).delete();
    } on FirebaseException catch (e) {
      throw UserRepositoryException.fromCode(e.code);
    }
  }
}
```

### Custom Exception Classes

**Always create custom exceptions for each repository operation:**

```dart
class UserRepositoryException implements Exception {
  const UserRepositoryException([
    this.message = 'An unknown error occurred.',
  ]);

  final String message;

  factory UserRepositoryException.fromCode(String code) {
    switch (code) {
      case 'permission-denied':
        return const UserRepositoryException(
          'Insufficient permissions to access user data.',
        );
      case 'not-found':
        return const UserRepositoryException('User not found.');
      case 'unavailable':
        return const UserRepositoryException(
          'Service temporarily unavailable.',
        );
      default:
        return const UserRepositoryException();
    }
  }
}
```

### Model Serialization

**Include both JSON and Firestore serialization methods:**

```dart
@JsonSerializable(explicitToJson: true)
class User extends Equatable {
  const User({
    required this.id,
    this.email,
    this.firstName,
    this.lastName,
  });

  final String id;
  final String? email;
  final String? firstName;
  final String? lastName;

  /// For general JSON serialization
  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
  Map<String, dynamic> toJson() => _$UserToJson(this);

  /// For Firestore (includes document ID)
  factory User.fromFirestore(Map<String, dynamic> data, String documentId) {
    return User(
      id: documentId,
      email: data['email'] as String?,
      firstName: data['first_name'] as String?,
      lastName: data['last_name'] as String?,
    );
  }

  /// For Firestore writes
  Map<String, dynamic> toFirestore() {
    return {
      'email': email,
      'first_name': firstName,
      'last_name': lastName,
      'updated_at': FieldValue.serverTimestamp(),
    };
  }

  @override
  List<Object?> get props => [id, email, firstName, lastName];
}
```

---

## Widget Best Practices

### Widget Organization

1. **Order of methods in StatelessWidget:**
   ```dart
   class MyWidget extends StatelessWidget {
     // 1. Constructor
     const MyWidget({required this.title, super.key});

     // 2. Properties
     final String title;

     // 3. Build method
     @override
     Widget build(BuildContext context) { }

     // 4. Private helper methods
     void _onPressed() { }
   }
   ```

2. **Extract complex widgets** into separate classes:
   ```dart
   // ❌ Avoid: Widget methods
   Widget _buildHeader() { }

   // ✅ Good: Separate widget classes
   class HeaderWidget extends StatelessWidget { }
   ```

3. **Use const constructors** to improve performance:
   ```dart
   const Text('Hello')
   const SizedBox(height: 16)
   const Padding(padding: EdgeInsets.all(8))
   ```

### BLoC Integration in Widgets

```dart
// === BlocBuilder (rebuild on state changes) ===
BlocBuilder<UserBloc, UserState>(
  builder: (context, state) {
    return state.when(
      initial: () => const SizedBox.shrink(),
      loading: () => const CircularProgressIndicator(),
      success: (user) => Text(user.name),
      failure: (message) => Text('Error: $message'),
    );
  },
)

// === BlocListener (side effects, no rebuild) ===
BlocListener<AuthBloc, AuthState>(
  listener: (context, state) {
    state.whenOrNull(
      failure: (message) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(message)),
        );
      },
    );
  },
  child: LoginForm(),
)

// === BlocConsumer (both builder and listener) ===
BlocConsumer<CartBloc, CartState>(
  listener: (context, state) {
    if (state is CartError) {
      context.showSnackBar(state.message);
    }
  },
  builder: (context, state) {
    if (state is CartLoading) return const LoadingIndicator();
    if (state is CartLoaded) return CartList(items: state.items);
    return const SizedBox.shrink();
  },
)
```

---

## Testing Requirements

### BLoC Tests

**Always write tests for Blocs using bloc_test:**

```dart
import 'package:bloc_test/bloc_test.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';

class MockUserRepository extends Mock implements UserRepository {}

void main() {
  group('UserBloc', () {
    late UserRepository userRepository;

    setUp(() {
      userRepository = MockUserRepository();
    });

    test('initial state is initial', () {
      final bloc = UserBloc(userRepository: userRepository);
      expect(bloc.state, const UserState.initial());
    });

    blocTest<UserBloc, UserState>(
      'emits [loading, success] when user subscription succeeds',
      build: () {
        when(() => userRepository.watchUser(any())).thenAnswer(
          (_) => Stream.value(const User(id: '1', name: 'Test')),
        );
        return UserBloc(userRepository: userRepository);
      },
      act: (bloc) => bloc.add(const UserSubscriptionRequested('1')),
      expect: () => [
        const UserState.loading(),
        const UserState.success(User(id: '1', name: 'Test')),
      ],
    );

    blocTest<UserBloc, UserState>(
      'emits [loading, failure] when user subscription fails',
      build: () {
        when(() => userRepository.watchUser(any())).thenAnswer(
          (_) => Stream.error(Exception('Network error')),
        );
        return UserBloc(userRepository: userRepository);
      },
      act: (bloc) => bloc.add(const UserSubscriptionRequested('1')),
      expect: () => [
        const UserState.loading(),
        const UserState.failure('Exception: Network error'),
      ],
    );
  });
}
```

### Repository Tests

```dart
void main() {
  group('UserRepository', () {
    late FakeFirebaseFirestore firestore;
    late UserRepository repository;

    setUp(() {
      firestore = FakeFirebaseFirestore();
      repository = UserRepository(firestore: firestore);
    });

    test('getUser returns user when document exists', () async {
      await firestore.collection('users').doc('1').set({
        'email': 'test@test.com',
        'first_name': 'Test',
        'last_name': 'User',
      });

      final user = await repository.getUser('1');

      expect(user, isNotNull);
      expect(user!.id, '1');
      expect(user.email, 'test@test.com');
    });

    test('getUser returns null when document does not exist', () async {
      final user = await repository.getUser('nonexistent');
      expect(user, isNull);
    });
  });
}
```

---

## Error Handling

### Try-Catch Pattern

```dart
Future<void> someAsyncOperation() async {
  try {
    // Operation
    await repository.doSomething();
  } on SpecificException catch (e) {
    // Handle specific exception
    emit(state.copyWith(errorMessage: e.message));
  } on FirebaseException catch (e) {
    // Handle Firebase exceptions
    emit(state.copyWith(errorMessage: FirebaseErrorHandler.getMessage(e)));
  } catch (e) {
    // Handle any other exception
    emit(state.copyWith(errorMessage: 'An unexpected error occurred'));
  }
}
```

### User-Friendly Error Messages

**Never expose raw exception messages to users:**

```dart
// ❌ Bad
catch (e) {
  showSnackBar(e.toString()); // Shows "Exception: FirebaseException..."
}

// ✅ Good
catch (e) {
  showSnackBar('Failed to load data. Please try again.');
}
```

---

## Comments & Documentation

### When to Add Comments

**✅ DO comment:**
- Complex business logic
- Non-obvious workarounds
- Public APIs (use triple-slash `///`)
- Why something is done (not what)

**❌ DON'T comment:**
- Self-explanatory code
- What code does (let code speak)
- Obvious things

### Documentation Comments

```dart
/// Authenticates user with Google Sign-In.
///
/// Throws [LogInWithGoogleFailure] if the sign-in fails.
/// Returns immediately if the user cancels the sign-in flow.
Future<void> logInWithGoogle() async {
  // Implementation
}
```

---

## Anti-Patterns to Avoid

### ❌ Don't Use BuildContext Across Async Gaps

```dart
// ❌ BAD
Future<void> onPressed(BuildContext context) async {
  await someAsyncOperation();
  Navigator.of(context).push(...); // Context might be invalid
}

// ✅ GOOD
Future<void> onPressed(BuildContext context) async {
  await someAsyncOperation();
  if (!context.mounted) return;
  Navigator.of(context).push(...);
}
```

### ❌ Don't Mutate State Directly

```dart
// ❌ BAD
state.items.add(newItem);
emit(state);

// ✅ GOOD
emit(state.copyWith(items: [...state.items, newItem]));
```

### ❌ Don't Perform Business Logic in Widgets

```dart
// ❌ BAD
ElevatedButton(
  onPressed: () async {
    final result = await _firestore.collection('users').doc(userId).get();
    // ... complex logic
  },
)

// ✅ GOOD
ElevatedButton(
  onPressed: () {
    context.read<UserBloc>().add(UserLoadRequested(userId));
  },
)
```

---

## Git Commit Messages

Follow conventional commits:

```
feat: add user authentication
fix: resolve logout error
refactor: extract user repository
test: add tests for auth bloc
docs: update README with setup instructions
```

---

## PR/Code Review Checklist

Before submitting code, ensure:

- [ ] All tests pass
- [ ] New code has tests
- [ ] No commented-out code
- [ ] No debug print statements
- [ ] Follows naming conventions
- [ ] BLoCs/Cubits properly documented
- [ ] Error handling in place
- [ ] No TODO comments (create issues instead)

---

## Performance Considerations

1. **Use const constructors** wherever possible
2. **Extract complex widgets** to avoid rebuilds
3. **Use keys** for lists: `key: ValueKey(item.id)`
4. **Avoid unnecessary rebuilds** with `BlocSelector`
5. **Cache network images** with `cached_network_image`

---

## When in Doubt

1. Check `CLAUDE.md` for architectural context
2. Look at existing features for patterns
3. Follow Effective Dart guidelines
4. Prefer simplicity over cleverness
5. Write tests to verify behavior

---

**Last Updated:** 2026-01-21
